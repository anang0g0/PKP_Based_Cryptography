# PKP_Based_Cryptography(delusion of invention)

20200620

ここで符号理論の常識からはみ出してみましょう。（ここからの議論は、もはや符号ではない）

ここでは長方形をした行列を公開鍵に持つ暗号を作ることが目的です。（主にPKPを使った方式を考える予定）

PKPを全く理解してませんが以下の論文を読むつもりです。
PKPの最初の応用はシャミアによる以下の論文です。

https://pdfs.semanticscholar.org/e2e6/ea153b618c71bc27abad680c6b93f999b53b.pdf

PKPを使った電子署名：
https://eprint.iacr.org/2018/714.pdf


無理やり計算する方法に依存しない方法を考えます。

通常、エラーとシンドロームが１対１の関係であるためには、エラーベクトルの重みが特定の数に決まっていなければなりません。
しかし、もしこの条件を取り除いてシンドロームと同じサイズのエラーを許せば、
部分符号の逆行列を計算するだけでどのような符号からも簡単にシンドロームに対応するエラーベクトルが決定できるかもしれない。（やってないので分からない）
つまり、シンドロームと符号の特定の位置さえ決まってしまえば、それに対応するエラーベクトルを計算することは簡単だと思われます。
バイナリ符号の場合は、値が変化しないのでこの方法がうまくいきそうな予感・・・。（検証はしてません）
異なる複数の符号間で１つのシンドロームに対応するエラーベクトルがいくらでも生成できるかもしれない。
しかし、これではどんなベクトルであろうと答えになるので、エラーパターンのハッシュ値かHMACと併用する必要があると思います。
（これは多重線形写像だろうか?という疑問があるけど、それは自分がペアリングの一般化を理解していない証拠でもある）

例えば、３２バイトの任意のシンドローム（例えばメールアドレス）に対応するエラーベクトルを計算したいものとする。
この場合、リードソロモン符号を使うなら、このシンドロームに対応するエラーを計算するために、任意の３２個の位置から符号列を取り出す。
そうして作られた正方行列の逆行列を計算してやり、シンドロームにかけてやれば、この場合メールアドレスに対応するエラーベクトルが決まるという訳です。

しかしこの問題は符号の性能を無視しているので、単なる長方形をした大きな行列で計算しているのと変わりがありません。

格子暗号のわかりやすい解説：
https://clean-copy-of-onenote.hatenablog.com/entry/intro_lattice_based_crypto?fbclid=IwAR2bEM2mi-oobg96U2q2buB3fXy9y6zKwpl3o4IOcKtru36RsX7xabU3uaM

ちなみに格子暗号は全く知りません。ｗ

結論：
部分符号から作られた正方行列を固定してしまうと、これはアフィン暗号と同じになってしまうので簡単に解読できますね。
（PKPが理解できていません。PKPは長方形の行列を使うようです）

ここでアフィン暗号からもう一度符号の問題に変換する。（再び符号の問題に戻る。）

まずメールアドレスから重み２ｔエラーベクトルを計算するために、上記の逆行列を計算する。（ここまではアフィン暗号）
その後で、この重み２ｔのエラーベクトルを２個の重みｔのエラーベクトルに分解する。
シンドロームも二つ生成するのだが、この二つに分割されたシンドロームをXORするとメールアドレスになります。

で、これで何かできないかを考え中。
